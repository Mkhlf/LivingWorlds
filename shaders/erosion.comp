#version 450
layout(local_size_x = 16, local_size_y = 16) in;

// Bindings
layout(set = 0, binding = 2, rgba8) uniform readonly image2D inputHeight;
layout(set = 0, binding = 3, rgba8) uniform writeonly image2D outputHeight;
layout(set = 0, binding = 8, r8ui) uniform readonly uimage2D inBiome;

// Push constants from UI
layout(push_constant) uniform ErosionParams {
    float rate;           // Base erosion rate (0.1-0.99)
    float bidrEnabled;    // 0.0 = off, 1.0 = on
    float forestMult;     // Forest erosion multiplier (0.05-1.0)
    float desertMult;     // Desert erosion multiplier (1.0-2.0)
    float sandMult;       // Sand erosion multiplier (1.5-4.0)
    float coastalBonus;   // Extra erosion near water (1.0-2.0)
} params;

// Biome IDs
const uint WATER   = 0u;
const uint SAND    = 1u;
const uint GRASS   = 2u;
const uint FOREST  = 3u;
const uint DESERT  = 4u;
const uint ROCK    = 5u;
const uint SNOW    = 6u;
const uint TUNDRA  = 7u;
const uint WETLAND = 8u;

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputHeight);
    
    if (pos.x >= size.x || pos.y >= size.y) return;

    float h = imageLoad(inputHeight, pos).r;
    uint biome = imageLoad(inBiome, pos).r;
    
    // Check for water neighbors (for coastal erosion)
    bool hasWaterNeighbor = false;
    float neighborSum = 0.0;
    
    for(int dy = -1; dy <= 1; dy++) {
        for(int dx = -1; dx <= 1; dx++) {
            if(dx == 0 && dy == 0) continue;
            ivec2 nPos = clamp(pos + ivec2(dx, dy), ivec2(0), size - ivec2(1));
            neighborSum += imageLoad(inputHeight, nPos).r;
            
            // Check for water neighbors
            uint neighborBiome = imageLoad(inBiome, nPos).r;
            if (neighborBiome == WATER) {
                hasWaterNeighbor = true;
            }
        }
    }
    float neighborAvg = neighborSum / 8.0;
    
    // Calculate erosion rate with bidir feedback
    float finalRate = params.rate;
    
    if (params.bidrEnabled > 0.5) {
        // Biome-specific erosion modifiers
        if (biome == FOREST) {
            finalRate *= params.forestMult; // Forest protects terrain
        } else if (biome == DESERT) {
            finalRate *= params.desertMult; // Desert erodes faster
        } else if (biome == SAND) {
            finalRate *= params.sandMult;   // Sand very erosive
            if (hasWaterNeighbor) {
                finalRate *= params.coastalBonus; // Wave action bonus
            }
        } else if (biome == ROCK) {
            finalRate *= 0.1;  // Rock very resistant
        } else if (biome == SNOW) {
            finalRate *= 0.05; // Snow/Ice very resistant
        } else if (biome == TUNDRA) {
            finalRate *= 0.3;  // Tundra moderately resistant (permafrost)
        } else if (biome == WETLAND) {
            finalRate *= 0.05; // Wetland very resistant (vegetation stabilizes)
        }
        
        // Any coastal cell gets bonus erosion (even non-sand)
        // But wetlands protect coastlines
        if (hasWaterNeighbor && biome != WATER && biome != FOREST && biome != WETLAND) {
            finalRate *= 1.2;  // All coastal areas erode faster
        }
    }
    
    // Soft clamp: preserve relative differences while capping at 0.95
    // Uses formula: scaled = target * rate / (rate + offset) where offset controls curve
    // This ensures higher multipliers still give higher rates, but never exceed 0.95
    if (finalRate > 0.5) {
        // Soft scaling for high rates
        finalRate = 0.5 + (finalRate - 0.5) / (1.0 + (finalRate - 0.5) * 0.5);
    }
    finalRate = clamp(finalRate, 0.0, 0.95);
    
    // Move towards neighbor average
    float newH = h + (neighborAvg - h) * finalRate;
    
    // Clamp
    newH = clamp(newH, 0.0, 1.0);
    
    imageStore(outputHeight, pos, vec4(newH, 0.0, 0.0, 0.0));
}

