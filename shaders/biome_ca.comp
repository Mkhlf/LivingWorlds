#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 2, rgba8) uniform readonly image2D heightMap;
layout(set = 0, binding = 8, r8ui) uniform readonly uimage2D inBiome;
layout(set = 0, binding = 9, r8ui) uniform writeonly uimage2D outBiome;

layout(push_constant) uniform PushConstants {
    float forestChance;
    float desertChance;
    int forestThreshold;
    int desertThreshold;
    float time;
} pc;

const uint WATER  = 0;
const uint SAND   = 1;
const uint GRASS  = 2;
const uint FOREST = 3;
const uint DESERT = 4;
const uint ROCK   = 5;
const uint SNOW   = 6;
const uint TUNDRA = 7;

// Good 2D hash
float hash2D(ivec2 p, float seed) {
    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973) + seed);
    p3 += dot(p3, p3.yxz + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

float hashF(ivec2 p) { return hash2D(p, pc.time * 0.01); }
float hashD(ivec2 p) { return hash2D(p, pc.time * 0.01 + 100.0); }
float hashT(ivec2 p) { return hash2D(p, pc.time * 0.01 + 200.0); }
float seedHash(ivec2 p) { return hash2D(p, 0.0); }

int countNeighbors(ivec2 pos, uint targetBiome, ivec2 size) {
    int count = 0;
    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            if (dx == 0 && dy == 0) continue;
            ivec2 nPos = clamp(pos + ivec2(dx, dy), ivec2(0), size - 1);
            if (imageLoad(inBiome, nPos).r == targetBiome) count++;
        }
    }
    return count;
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outBiome);
    if (pos.x >= size.x || pos.y >= size.y) return;

    float h = imageLoad(heightMap, pos).r;
    uint current = imageLoad(inBiome, pos).r;
    uint newBiome = current;
    
    float rF = hashF(pos);
    float rD = hashD(pos);
    float rT = hashT(pos);
    float rS = seedHash(pos);

    int forestCount = countNeighbors(pos, FOREST, size);
    int desertCount = countNeighbors(pos, DESERT, size);
    int grassCount = countNeighbors(pos, GRASS, size);
    int sameCount = countNeighbors(pos, current, size);
    int waterCount = countNeighbors(pos, WATER, size);
    int sandCount = countNeighbors(pos, SAND, size);

    // LOCATION CHECKS - Only apply bias at IMMEDIATE proximity
    // Most cells should be NEUTRAL for fair competition
    bool nearWater = (waterCount >= 1 || sandCount >= 1);  // Touching water/sand
    // No "inland" bias - removed to keep balance
    // All non-coastal cells are neutral

    // HEIGHT CONSTRAINTS
    if (h < 0.30) {
        newBiome = WATER;
    } else if (h < 0.35) {
        newBiome = SAND;
    } else if (h > 0.85) {
        newBiome = SNOW;
    } else if (h > 0.78) {
        newBiome = ROCK;
    } else if (h > 0.72) {
        newBiome = TUNDRA;
    } else {
        // MAIN LAND
        if (current == WATER || current == SAND || current == ROCK || 
            current == SNOW || current == TUNDRA) {
            newBiome = GRASS;
        }
        
        // CLUSTER STABILITY
        bool isDeepInCluster = (sameCount >= 6);
        bool isAtEdge = (sameCount <= 3);
        
        // SEEDING (first 10 steps)
        if (pc.time < 10.0 && pc.forestChance > 0.01 && current == GRASS) {
            float threshold = 0.025 * pc.forestChance;
            if (rS < threshold) {
                // Coast seeds forest, else 50/50
                if (nearWater) {
                    newBiome = FOREST;
                } else {
                    newBiome = ((pos.x + pos.y) % 2 == 0) ? FOREST : DESERT;
                }
            }
        }
        
        // === GRASS: Location-aware spreading ===
        if (current == GRASS) {
            // Base spread chances (EQUAL for balance)
            float forestSpread = 0.05;
            float desertSpread = 0.05;
            
            // ONLY coastal forest bonus, no inland desert bonus
            if (nearWater) {
                forestSpread = 0.08;  // Forest +60% near water
                desertSpread = 0.03;  // Desert -40% near water
            }
            // All other cells stay at 5%/5% - balanced
            
            bool forestWants = (forestCount >= 3 && rF < forestSpread);
            bool desertWants = (desertCount >= 3 && rD < desertSpread);
            
            if (forestWants && desertWants) {
                newBiome = (rT < 0.5) ? FOREST : DESERT;
            } else if (forestWants) {
                newBiome = FOREST;
            } else if (desertWants) {
                newBiome = DESERT;
            }
            
            // Spontaneous seeding
            float seedRate = (pc.forestChance < 0.01) ? 0.003 : 0.0005;
            if (rT < seedRate && newBiome == GRASS) {
                newBiome = (rF < 0.5) ? FOREST : DESERT;
            }
        }
        
        // === FOREST ===
        if (current == FOREST) {
            // Deep in cluster - very stable
            if (isDeepInCluster) {
                // Almost never changes
                if (desertCount >= 6 && rF < 0.005) {
                    newBiome = GRASS;
                }
            } else if (isAtEdge) {
                // At edge - can be converted
                if (desertCount >= 3 && rF < 0.04) {
                    newBiome = GRASS;
                }
            }
            // Isolation death
            if (sameCount == 0 && rF < 0.1) {
                newBiome = GRASS;
            }
        }
        
        // === DESERT === (same as forest)
        if (current == DESERT) {
            if (isDeepInCluster) {
                if (forestCount >= 6 && rD < 0.005) {
                    newBiome = GRASS;
                }
            } else if (isAtEdge) {
                if (forestCount >= 3 && rD < 0.04) {
                    newBiome = GRASS;
                }
            }
            if (sameCount == 0 && rD < 0.1) {
                newBiome = GRASS;
            }
        }
    }

    imageStore(outBiome, pos, uvec4(newBiome, 0, 0, 0));
}
