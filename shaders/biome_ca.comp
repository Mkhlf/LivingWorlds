#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 2, rgba8) uniform readonly image2D heightMap;
layout(set = 0, binding = 8, r8ui) uniform readonly uimage2D inBiome;
layout(set = 0, binding = 9, r8ui) uniform writeonly uimage2D outBiome;

layout(push_constant) uniform PushConstants {
    // Forest/Desert spreading
    float forestChance;
    float desertChance;
    int forestThreshold;
    int desertThreshold;
    float time;
    
    // Wetland dynamics
    float wetlandFormRate;
    float wetlandSpreadRate;
    float wetlandMaxHeight;
    
    // Mountain dynamics
    float snowMeltRate;
    float snowSpreadRate;
    float tundraSpreadRate;
    float treeLineHeight;
} pc;

const uint WATER   = 0;
const uint SAND    = 1;
const uint GRASS   = 2;
const uint FOREST  = 3;
const uint DESERT  = 4;
const uint ROCK    = 5;
const uint SNOW    = 6;
const uint TUNDRA  = 7;
const uint WETLAND = 8;

// Good 2D hash
float hash2D(ivec2 p, float seed) {
    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973) + seed);
    p3 += dot(p3, p3.yxz + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

float hashF(ivec2 p) { return hash2D(p, pc.time * 0.01); }
float hashD(ivec2 p) { return hash2D(p, pc.time * 0.01 + 100.0); }
float hashT(ivec2 p) { return hash2D(p, pc.time * 0.01 + 200.0); }
float seedHash(ivec2 p) { return hash2D(p, 0.0); }

int countNeighbors(ivec2 pos, uint targetBiome, ivec2 size) {
    int count = 0;
    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            if (dx == 0 && dy == 0) continue;
            ivec2 nPos = clamp(pos + ivec2(dx, dy), ivec2(0), size - 1);
            if (imageLoad(inBiome, nPos).r == targetBiome) count++;
        }
    }
    return count;
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outBiome);
    if (pos.x >= size.x || pos.y >= size.y) return;

    float h = imageLoad(heightMap, pos).r;
    uint current = imageLoad(inBiome, pos).r;
    uint newBiome = current;
    
    float rF = hashF(pos);
    float rD = hashD(pos);
    float rT = hashT(pos);
    float rS = seedHash(pos);

    int forestCount = countNeighbors(pos, FOREST, size);
    int desertCount = countNeighbors(pos, DESERT, size);
    int grassCount = countNeighbors(pos, GRASS, size);
    int sameCount = countNeighbors(pos, current, size);
    int waterCount = countNeighbors(pos, WATER, size);
    int sandCount = countNeighbors(pos, SAND, size);
    int wetlandCount = countNeighbors(pos, WETLAND, size);
    int snowCount = countNeighbors(pos, SNOW, size);
    int tundraCount = countNeighbors(pos, TUNDRA, size);
    int rockCount = countNeighbors(pos, ROCK, size);

    // LOCATION CHECKS - Only apply bias at IMMEDIATE proximity
    // Most cells should be NEUTRAL for fair competition
    bool nearWater = (waterCount >= 1 || sandCount >= 1);  // Touching water/sand
    // No "inland" bias - removed to keep balance
    // All non-coastal cells are neutral

    // HEIGHT CONSTRAINTS (now with dynamic spreading)
    if (h < 0.30) {
        newBiome = WATER;
    } else if (h < 0.35) {
        newBiome = SAND;
    } else if (h > 0.85) {
        // Peak elevation - always snow
        newBiome = SNOW;
    } else if (h > 0.72) {
        // Mountain zone - height-based defaults with dynamic transitions
        
        // Step 1: Set height-based defaults for cells that need initialization
        if (current == GRASS || current == WATER || current == SAND || current == DESERT || current == FOREST) {
            // Convert lowland biomes to mountain biomes based on height
            if (h > 0.82) {
                newBiome = SNOW;  // High mountain
            } else if (h > 0.78) {
                newBiome = ROCK;  // Upper mountain
            } else {
                newBiome = TUNDRA;  // Alpine meadow
            }
        }
        
        // Step 2: Dynamic transitions (only for cells already in mountain biomes)
        // Snow melts into tundra at lower elevations
        if (current == SNOW && h < 0.82) {
            if (rT < pc.snowMeltRate) {
                newBiome = TUNDRA;
            }
        }
        
        // Snow spreads downhill from existing snow
        if (current == ROCK && snowCount >= 2 && h > 0.78) {
            if (rT < pc.snowSpreadRate) {
                newBiome = SNOW;
            }
        }
        if (current == TUNDRA && snowCount >= 3 && h > 0.76) {
            if (rT < pc.snowSpreadRate * 0.5) {
                newBiome = SNOW;
            }
        }
        
        // Tundra spreads from existing tundra
        if (current == ROCK && tundraCount >= 2 && h < 0.80) {
            if (rT < pc.tundraSpreadRate) {
                newBiome = TUNDRA;
            }
        }
        
        // Tree line: tundra can become forest at lower edge
        if (current == TUNDRA && h < pc.treeLineHeight && forestCount >= 2) {
            if (rT < pc.tundraSpreadRate * 0.3) {
                newBiome = FOREST;
            }
        }
    } else {
        // MAIN LAND (exclude WETLAND - it's a valid stable biome)
        if (current == WATER || current == SAND || current == ROCK || 
            current == SNOW || current == TUNDRA) {
            newBiome = GRASS;
        }
        
        // CLUSTER STABILITY
        bool isDeepInCluster = (sameCount >= 6);
        bool isAtEdge = (sameCount <= 3);
        
        // SEEDING (first 10 steps)
        if (pc.time < 10.0 && pc.forestChance > 0.01 && current == GRASS) {
            float threshold = 0.025 * pc.forestChance;
            if (rS < threshold) {
                // Coast seeds forest, else 50/50
                if (nearWater) {
                    newBiome = FOREST;
                } else {
                    newBiome = ((pos.x + pos.y) % 2 == 0) ? FOREST : DESERT;
                }
            }
        }
        
        // === GRASS: Location-aware spreading ===
        if (current == GRASS) {
            // Base spread chances scaled by push constants
            float forestSpread = 0.05 * pc.forestChance;
            float desertSpread = 0.05 * pc.desertChance;
            
            // Coastal modifiers
            if (nearWater) {
                forestSpread *= 1.5;  // Forest +50% near water
                desertSpread *= 0.5;  // Desert -50% near water
            }
            
            // Use push constant thresholds
            bool forestWants = (forestCount >= pc.forestThreshold && rF < forestSpread);
            bool desertWants = (desertCount >= pc.desertThreshold && rD < desertSpread);
            
            if (forestWants && desertWants) {
                newBiome = (rT < 0.5) ? FOREST : DESERT;
            } else if (forestWants) {
                newBiome = FOREST;
            } else if (desertWants) {
                newBiome = DESERT;
            }
            
            // Spontaneous seeding
            float seedRate = (pc.forestChance < 0.01) ? 0.003 : 0.0005;
            if (rT < seedRate && newBiome == GRASS) {
                newBiome = (rF < 0.5) ? FOREST : DESERT;
            }
        }
        
        // === FOREST ===
        if (current == FOREST) {
            // Deep in cluster - very stable
            if (isDeepInCluster) {
                // Almost never changes
                if (desertCount >= 6 && rF < 0.005) {
                    newBiome = GRASS;
                }
            } else if (isAtEdge) {
                // At edge - can be converted
                if (desertCount >= 3 && rF < 0.04) {
                    newBiome = GRASS;
                }
            }
            // Isolation death
            if (sameCount == 0 && rF < 0.1) {
                newBiome = GRASS;
            }
            // Tree line: forest above tree line becomes tundra
            // No tundra neighbor required - height alone determines tree line
            if (h > pc.treeLineHeight) {
                if (rT < pc.tundraSpreadRate) {
                    newBiome = TUNDRA;
                }
            }
        }
        
        // === DESERT === (same as forest)
        if (current == DESERT) {
            if (isDeepInCluster) {
                if (forestCount >= 6 && rD < 0.005) {
                    newBiome = GRASS;
                }
            } else if (isAtEdge) {
                if (forestCount >= 3 && rD < 0.04) {
                    newBiome = GRASS;
                }
            }
            if (sameCount == 0 && rD < 0.1) {
                newBiome = GRASS;
            }
        }
        
        // === WETLAND ===
        // Forms where forest meets water at low elevation
        if (current == FOREST && nearWater && h < pc.wetlandMaxHeight && h > 0.35) {
            if (rT < pc.wetlandFormRate) {
                newBiome = WETLAND;
            }
        }
        
        // Wetland spreads along water edges (thicker strips)
        if (current == GRASS && nearWater && wetlandCount >= 1 && h < pc.wetlandMaxHeight) {
            if (rT < pc.wetlandSpreadRate) {
                newBiome = WETLAND;
            }
        }
        
        // Wetland grows from forest near water (grows inland)
        if (current == GRASS && wetlandCount >= 2 && forestCount >= 1 && h < pc.wetlandMaxHeight) {
            if (rT < pc.wetlandSpreadRate * 0.6) {
                newBiome = WETLAND;
            }
        }
        
        // Wetlands reclaim adjacent sand (vegetation blocks sand)
        if (current == SAND && wetlandCount >= 2) {
            if (rT < pc.wetlandSpreadRate * 0.4) {
                newBiome = WETLAND;
            }
        }
        
        // Wetland blocks sand formation
        if (current == GRASS && nearWater && wetlandCount > 0 && h < 0.4) {
            // Cannot become sand if wetland nearby
            if (newBiome == SAND) {
                newBiome = GRASS;
            }
        }
        
        // Wetland stability (very stable)
        if (current == WETLAND) {
            // Wetland persists - only very slowly dries up if isolated from water
            if (!nearWater && wetlandCount == 0 && rT < 0.005) {
                newBiome = GRASS;  // Very rare drying
            }
            // Otherwise wetland persists
        }
    }

    imageStore(outBiome, pos, uvec4(newBiome, 0, 0, 0));
}
